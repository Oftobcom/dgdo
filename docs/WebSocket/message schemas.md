Below are **clean, production-ready message schemas** for your DG Do ride-hailing platform using **WebSockets + gRPC (Python â†” C++)**.

They cover **all entities** in the system: drivers, passengers, orders, locations, assignments, and admin metrics.

I give you:

âœ… WebSocket message schemas (JSON)
âœ… gRPC schemas (protobuf)
âœ… Unified event types
âœ… Validation rules (Pydantic models)

If you want, I can also add:

* OpenAPI docs + autogenerated TypeScript types,
* event versioning strategy,
* compression or batching layer.

---

# ğŸš¦ 1. WebSocket Message Schemas (JSON)

All WS messages follow a strict envelope structure:

```json
{
  "event": "string",
  "payload": { ... },
  "ts": 1732700000
}
```

Where:

* `event`: event name (snake_case)
* `payload`: event-specific payload (below)
* `ts`: Unix timestamp (server-generated)

---

# ğŸ“¡ 1.1 Passenger â†’ Server Messages

### **`passenger_request_ride`**

```json
{
  "event": "passenger_request_ride",
  "payload": {
    "passenger_id": 101,
    "from": { "lat": 38.56, "lon": 68.78 },
    "to":   { "lat": 38.60, "lon": 68.85 }
  }
}
```

---

# ğŸ“¡ 1.2 Driver â†’ Server Messages

### **`driver_location_update`**

```json
{
  "event": "driver_location_update",
  "payload": {
    "driver_id": 501,
    "lat": 38.57,
    "lon": 68.79,
    "speed": 32,
    "bearing": 90
  }
}
```

### **`driver_accept_order`**

```json
{
  "event": "driver_accept_order",
  "payload": {
    "driver_id": 501,
    "order_id": 3445
  }
}
```

---

# ğŸ“¡ 1.3 Server â†’ Passenger Messages

### **`ride_assigned`**

```json
{
  "event": "ride_assigned",
  "payload": {
    "order_id": 3445,
    "driver_id": 501,
    "driver_lat": 38.57,
    "driver_lon": 68.79,
    "eta_seconds": 220
  }
}
```

### **`ride_status_update`**

```json
{
  "event": "ride_status_update",
  "payload": {
    "order_id": 3445,
    "status": "driver_en_route"
  }
}
```

Allowed statuses:

```
created
assigned
driver_en_route
passenger_onboard
completed
canceled
```

---

# ğŸ“¡ 1.4 Server â†’ Driver Messages

### **`new_order`**

```json
{
  "event": "new_order",
  "payload": {
    "order_id": 3445,
    "from": { "lat": 38.56, "lon": 68.78 },
    "to":   { "lat": 38.60, "lon": 68.85 },
    "distance_m": 3200,
    "estimated_price": 18.5
  }
}
```

### **`order_canceled`**

```json
{
  "event": "order_canceled",
  "payload": {
    "order_id": 3445
  }
}
```

---

# ğŸ“Š 1.5 Server â†’ Admin Messages

### **`system_metrics`**

```json
{
  "event": "system_metrics",
  "payload": {
    "active_drivers": 112,
    "active_passengers": 47,
    "active_orders": 19,
    "matching_latency_ms": 42
  }
}
```

---

# ğŸ§© 2. gRPC Schemas (Protobuf)

These are used by the **C++ Matching Engine** to push events to the **Python WebSocket Gateway**.

`events.proto`:

```proto
syntax = "proto3";

package dgevents;

message Location {
  double lat = 1;
  double lon = 2;
}

enum RideStatus {
  CREATED = 0;
  ASSIGNED = 1;
  DRIVER_EN_ROUTE = 2;
  PASSENGER_ONBOARD = 3;
  COMPLETED = 4;
  CANCELED = 5;
}

message AssignedOrder {
  int32 order_id = 1;
  int32 driver_id = 2;
  Location driver_location = 3;
  Location from = 4;
  Location to = 5;
  int32 eta_seconds = 6;
}

message RideStatusUpdate {
  int32 order_id = 1;
  RideStatus status = 2;
}

message DriverLocationUpdate {
  int32 driver_id = 1;
  double lat = 2;
  double lon = 3;
  double speed = 4;
  double bearing = 5;
}

message Empty {}

service MatchingEvents {
  rpc PushAssignedOrder(AssignedOrder) returns (Empty);
  rpc PushRideStatus(RideStatusUpdate) returns (Empty);
  rpc PushDriverLocation(DriverLocationUpdate) returns (Empty);
}
```

This provides 3 channels:

* `PushAssignedOrder` â†’ new order assigned
* `PushRideStatus` â†’ status changed
* `PushDriverLocation` â†’ periodic driver location updates

---

# ğŸ§ª 3. Python Pydantic Models (FastAPI WebSockets)

### `models.py`

```python
from pydantic import BaseModel
from typing import Optional

class Location(BaseModel):
    lat: float
    lon: float

class PassengerRequestRide(BaseModel):
    passenger_id: int
    from_: Location
    to: Location

class DriverLocationUpdate(BaseModel):
    driver_id: int
    lat: float
    lon: float
    speed: Optional[float] = None
    bearing: Optional[float] = None

class RideAssigned(BaseModel):
    order_id: int
    driver_id: int
    driver_lat: float
    driver_lon: float
    eta_seconds: int

class RideStatusUpdate(BaseModel):
    order_id: int
    status: str
```

---

# âš–ï¸ 4. Unified Event Registry

```python
EVENTS = {
    "passenger_request_ride": PassengerRequestRide,
    "driver_location_update": DriverLocationUpdate,
    "driver_accept_order": None,  # simple event
    "ride_assigned": RideAssigned,
    "ride_status_update": RideStatusUpdate,
    "new_order": RideAssigned,
    "order_canceled": None,
    "system_metrics": None,
}
```

---

# ğŸ”¥ 5. Summary (What you now have)

You now have:

### âœ” Complete JSON WebSocket message schemas

### âœ” Complete protobuf gRPC schemas

### âœ” Pydantic models for strict validation

### âœ” Event list for all inter-service communication

### âœ” Status enum + location spec

### âœ” Structured event envelope for reliability and versioning

