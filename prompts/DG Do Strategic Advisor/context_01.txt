I’m developing the open-source project “DG Do Matching Engine”, a ride-hailing platform similar to Uber, Lyft, Bolt, and Yandex Go.


# DG Do — Canonical Domain Laws (Version 0.1)

> **Non-negotiable rules:** violating these breaks production.
> Experiments may run outside production only.

## 1. TripRequest Laws

1. `TripRequest` may exist without a driver.
2. Only **one active TripRequest per passenger** at a time. Creating a new one must fail or cancel the previous request.
3. `TripRequest` must have valid origin and destination (`dgdo.common.Location`).
4. **Cold-start fallback**: if no drivers are available, TripRequest is queued for later assignment; passenger must be notified of estimated wait.
5. **Cancellation rules**: passengers may cancel TripRequest before driver assignment; cancellation after assignment triggers driver notification.
6. **Geo-edge cases**: TripRequest outside serviceable region must fail with clear error code.

## 2. Trip Laws

1. `Trip` **MUST have a driver at creation**.
2. `Trip` **MUST reference a valid TripRequest ID**.
3. **Immutable fields**: origin, destination, passenger_id, driver_id.
4. **Lifecycle transitions** (status field) strictly allowed:

   ```
   ACCEPTED → EN_ROUTE → COMPLETED
   ACCEPTED → CANCELLED
   EN_ROUTE → COMPLETED
   EN_ROUTE → CANCELLED (driver exception)
   ```
5. Only **TripService can create or mutate Trip**.
6. Trip creation is **idempotent** by request_id.
7. **Failure handling**: if driver drops out mid-trip, TripService must:

   * Mark trip as `CANCELLED_BY_DRIVER`
   * Attempt auto-reassignment (if enabled)
   * Notify passenger
8. **Time consistency**: all timestamps immutable, in UTC.

## 3. MatchingService Laws

1. Matching **never mutates Trip**.
2. Returns a **finite candidate set** (`max_candidates` respected).
3. Returns **probability distribution** over drivers: sum = 1 ± ε; sorted descending by probability.
4. **Deterministic for same input + seed**.
5. Only **available drivers** may appear in candidates.
6. **Cold-start**: if candidate set empty, return empty set with reason code; API Gateway triggers fallback.
7. **Failure safety**: if MatchingService crashes mid-request, API Gateway retries using idempotent input & same seed.

## 4. API Gateway / Orchestration Laws

1. Samples **one driver** from MatchingService distribution; sampling occurs **here**, not in MatchingService.
2. Logs every sampling event: request_id, candidate list, probabilities, sampled driver, seed, timestamp.
3. **Retry safety**: re-sampling does not mutate original probabilities.
4. Does **not create Trip directly**; forwards CreateTripCommand to TripService.
5. **Crash resilience**: if TripService rejects or fails, API Gateway must retry (idempotent) or queue for async recovery.
6. **Cold-start handling**: if no drivers, inform passenger with ETA or alternative options; persist TripRequest in queue.

## 5. Driver / Passenger Laws

1. Only drivers flagged as **available** may appear in MatchingService.
2. Drivers cannot be assigned to multiple trips simultaneously.
3. Passengers may have only **one active TripRequest** at a time.
4. **Driver drop-off / GPS loss**: driver marked unavailable if unreachable; trips in progress handled by TripService fallback.

## 6. Operational / Scaling Laws

1. All gRPC calls that can be retried are **idempotent**.
2. **Telemetry required** for every Trip creation, driver match, TripRequest event, failures, retries, cancellations.
3. **Time consistency**: all timestamps in UTC, immutable after creation.
4. Generated code **must never be edited manually**; .proto files are the single source of truth.
5. System **must enforce invariants via automated tests**; failing tests = cannot deploy.
6. **Load scaling**: MatchingService must degrade gracefully under high load (return top-k candidates, queue excess requests).

## 7. Probabilistic / ML Laws

1. Probabilities returned by MatchingService are **immutable once computed**.
2. Candidate distributions logged for ML training; any post-computation mutation forbidden.
3. Sampling is seeded for deterministic replay.
4. **Cold-start learning**: system tracks unmatched TripRequests, driver shortages, and out-of-service areas; feed into ML model for probability adjustment.
5. **Data drift detection**: ML pipeline must monitor candidate selection performance over time; trigger model retraining if metrics drop below threshold.
6. **Failure logging**: all mismatches, retries, and drop-outs are logged for future training and system improvement.
