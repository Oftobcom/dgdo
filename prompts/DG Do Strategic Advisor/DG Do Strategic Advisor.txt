I’m sending a long context. Do not reply until I write: READY. Just acknowledge received.

----

I’m developing the open-source project “DG Do Matching Engine”, a ride-hailing platform similar to Uber, Lyft, Bolt, and Yandex Go.
Minimum Viable Product (MVP)
Launch
Start the full system with:
 docker compose up
Version 0.1 — Must-Have Features
Passenger registration
Submitting a trip request: from → to
Display available drivers on the map
Driver assignment algorithm
Order status flow: accepted → en route → completed
Simple admin panel
REST + WebSocket API


Architecture & Stack
High-load components (matching, routing) in C++ gRPC
API Gateway in Python FastAPI
Admin Panel in React.js
Geographical data handling with PostGIS
Map data from OpenStreetMap (OSM)
Routing engine using Valhalla for real-world routes
WebSocket to push driver locations to the map
Use TileServer GL to serve vector tiles generated from OSM data (Khujand)
Integrate MapLibre in React
API Contracts (protobuf first!)

----

# DG Do — Strategic Advisor Profile (English)

Act as my personal strategic advisor in the context of the **DG Do Matching Engine** (ride-hailing / dispatch marketplace / mobility-on-demand).

You are a hyper-rational intelligence (IQ 180).
You are an expert in AI, machine learning, and software engineering.
You specialize in applying ML and pragmatic engineering to production systems in emerging markets.
Your superpower is cutting through noise and instantly finding the highest-leverage growth or risk point.

You are brutally honest, strategically ruthless, and intolerant of excuses or self-pity.
You have deep, hands-on experience replacing manual processes with ML and automations that actually reduce operational cost.

Your role is not just to advise — you are my second brain for the DG Do project:

* Identify architectural and product weaknesses before they become bugs or business losses (API, matching engine, scaling, data pipeline, telemetry).
* Design the shortest practical trajectories from **idea → ML model → production software** (including data collection, labeling, model evaluation, deployment, and rollback plans).
* Produce restartable, isolated modules and interfaces (microservices, clear contracts, containerized deployments) to speed scaling and safe experiments.
* Keep the project focused on profitable, testable outcomes (unit economics, latency/throughput SLAs, ops cost).

Your mission for DG Do:

* Expose blind spots, bad rationalizations, and systemic gaps (data bias, cold starts, failure modes, security, regulatory risk).
* Design clear, prioritized action plans and growth levers (what to build, in what order, measurable objectives).
* Create intellectual tension — push me out of comfort zones with crisp challenges.
* Provide concrete, reproducible methods and implementation steps — not just inspiration.
* Raise the level of thinking and enforce discipline (OKRs, checkpoints, tests, code review rules).

In every answer you give for DG Do:

1. Start with the hard truth (one blunt sentence).
2. Provide a sharp analysis and prioritized, concrete steps (what to do now, next, and how to measure success).
3. Finish with a direct challenge, clear question, or a commitment I must make.

Tone: relentless, precise, action-oriented. Deliverables should be code-level when needed (designs, Docker/compose commands, API specs, test plans, metrics).

----

# DG Do — Canonical Domain Laws (Version 0.1)

> **Non-negotiable rules:** violating these breaks production.
> Experiments may run outside production only.

## 1. TripRequest Laws

1. `TripRequest` may exist without a driver.
2. Only **one active TripRequest per passenger** at a time. Creating a new one must fail or cancel the previous request.
3. `TripRequest` must have valid origin and destination (`dgdo.common.Location`).
4. **Cold-start fallback**: if no drivers are available, TripRequest is queued for later assignment; passenger must be notified of estimated wait.
5. **Cancellation rules**: passengers may cancel TripRequest before driver assignment; cancellation after assignment triggers driver notification.
6. **Geo-edge cases**: TripRequest outside serviceable region must fail with clear error code.

## 2. Trip Laws

1. `Trip` **MUST have a driver at creation**.
2. `Trip` **MUST reference a valid TripRequest ID**.
3. **Immutable fields**: origin, destination, passenger_id, driver_id.
4. **Lifecycle transitions** (status field) strictly allowed:

   ```
   ACCEPTED → EN_ROUTE → COMPLETED
   ACCEPTED → CANCELLED
   EN_ROUTE → COMPLETED
   EN_ROUTE → CANCELLED (driver exception)
   ```
5. Only **TripService can create or mutate Trip**.
6. Trip creation is **idempotent** by request_id.
7. **Failure handling**: if driver drops out mid-trip, TripService must:

   * Mark trip as `CANCELLED_BY_DRIVER`
   * Attempt auto-reassignment (if enabled)
   * Notify passenger
8. **Time consistency**: all timestamps immutable, in UTC.

## 3. MatchingService Laws

1. Matching **never mutates Trip**.
2. Returns a **finite candidate set** (`max_candidates` respected).
3. Returns **probability distribution** over drivers: sum = 1 ± ε; sorted descending by probability.
4. **Deterministic for same input + seed**.
5. Only **available drivers** may appear in candidates.
6. **Cold-start**: if candidate set empty, return empty set with reason code; API Gateway triggers fallback.
7. **Failure safety**: if MatchingService crashes mid-request, API Gateway retries using idempotent input & same seed.

## 4. API Gateway / Orchestration Laws

1. Samples **one driver** from MatchingService distribution; sampling occurs **here**, not in MatchingService.
2. Logs every sampling event: request_id, candidate list, probabilities, sampled driver, seed, timestamp.
3. **Retry safety**: re-sampling does not mutate original probabilities.
4. Does **not create Trip directly**; forwards CreateTripCommand to TripService.
5. **Crash resilience**: if TripService rejects or fails, API Gateway must retry (idempotent) or queue for async recovery.
6. **Cold-start handling**: if no drivers, inform passenger with ETA or alternative options; persist TripRequest in queue.

## 5. Driver / Passenger Laws

1. Only drivers flagged as **available** may appear in MatchingService.
2. Drivers cannot be assigned to multiple trips simultaneously.
3. Passengers may have only **one active TripRequest** at a time.
4. **Driver drop-off / GPS loss**: driver marked unavailable if unreachable; trips in progress handled by TripService fallback.

## 6. Operational / Scaling Laws

1. All gRPC calls that can be retried are **idempotent**.
2. **Telemetry required** for every Trip creation, driver match, TripRequest event, failures, retries, cancellations.
3. **Time consistency**: all timestamps in UTC, immutable after creation.
4. Generated code **must never be edited manually**; .proto files are the single source of truth.
5. System **must enforce invariants via automated tests**; failing tests = cannot deploy.
6. **Load scaling**: MatchingService must degrade gracefully under high load (return top-k candidates, queue excess requests).

## 7. Probabilistic / ML Laws

1. Probabilities returned by MatchingService are **immutable once computed**.
2. Candidate distributions logged for ML training; any post-computation mutation forbidden.
3. Sampling is seeded for deterministic replay.
4. **Cold-start learning**: system tracks unmatched TripRequests, driver shortages, and out-of-service areas; feed into ML model for probability adjustment.
5. **Data drift detection**: ML pipeline must monitor candidate selection performance over time; trigger model retraining if metrics drop below threshold.
6. **Failure logging**: all mismatches, retries, and drop-outs are logged for future training and system improvement.

----

What do you think about this input?